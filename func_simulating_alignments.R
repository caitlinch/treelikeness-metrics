#### caitlinch/treelikeness_metrics/func_simulating_alignment.R
## This file contains functions to simulate DNA multiple sequence alignments with varying levels of treelikeness

## Load required packages
library(ape)
library(phangorn)



## Functions to generate and manipulate trees
generate.random.trees <- function(num_trees, num_taxa, output_filepath = NA){
  # This function generates n random trees with m taxa (where n is set by num_trees and m is set by num_taxa)
  # Using the `ape` function `rtree`, trees are generated by randomly splitting the edges
  
  # Generate random trees
  trees <- rmtree(num_trees, num_taxa)
  
  # If output filepath is provided, save trees to file
  if (!is.na(output_filepath) == TRUE){
    write.tree(trees, file = output_filepath)
  }
}

generate.NNI.trees <- function(num_trees, num_taxa, NNI_moves, output_filepath = NA){
  # This function generates a random tree with m taxa, and then (n-1) related trees by performing a single NNI move on the starting tree
  # (where n is num_trees and m is num_taxa)
  # Generate a single random tree using the `ape` function `rtree` 
  starting_tree <- rtree(num_taxa)
  # Determine the total number of related trees to generate
  num_related_trees = num_trees - 1
  # Perform NNI moves
  related_trees <- rNNI(starting_tree, NNI_moves, num_related_trees)
  # Collate all trees into a single multiphylo object
  trees <-  c(starting_tree, related_trees)
  
  # If output filepath is provided, save trees to file
  if (!is.na(output_filepath) == TRUE){
    write.tree(trees, file = output_filepath)
  }
}


## Functions to generate partition files
partition.random.trees <- function(num_trees, al_length, sequence_type, models = NA, rescaled_tree_lengths = NA, output_filepath){
  # This function generates a charpartition file for n genes (where n is num_trees) of length al_length/n 
  
  # Generate charsets
  # Find start and end point of each gene in the total alignment length
  gene_start_points <- seq(1, al_length, (al_length/num_trees))
  gene_end_points <- seq((al_length/num_trees), al_length, (al_length/num_trees))
  # Name genes
  gene_names <- sprintf("gene_%05d",1:num_trees)
  # Paste arguments together into charset lines
  csets <- paste0("\tcharset ", gene_names, " = ", sequence_type, ", ", gene_start_points, "-", gene_end_points, ";")
  
  # Generate model arguments
  if (!is.na(models) == TRUE){
    # If models have been provided, generate a charpartition line for the partition file
    # "models" should be a list of models with one model corresponding to one gene, or 1 model to be applied to all genes
    if (is.na(rescaled_tree_lengths) == TRUE){
      # If no rescaled_tree_lengths are provided, create the chpartitions by directly assembling the models and gene names
      gene_models <- paste0(models, ":", gene_names)
    } else if (is.na(rescaled_tree_lengths) == FALSE){
      # If rescaled_gene_lengths are provided, add them to the gene_models vector. 
      # This allows different genes to have different evolutionary rates (by specifying gene-specific tree lengths within the charpartition command)
      gene_models <- paste0(models, ":", gene_names, "{", rescaled_tree_lengths, "}")
    }
    # Assemble all sections of the charpartition command
    cpart <- paste0("\tcharpartition genes = ", paste(gene_models, collapse = ", "), ";")
  } else{
    # If no models provided, do not create a charpartition line for the partition file
    cpart <- NULL
  }
  
  # Assemble components into partition file
  c_file <- c("#nexus", "begin sets;", csets, cpart, "end;")
  
  # Write partition file
  write(c_file, file = output_filepath)
}



## Functions to simulate alignments in Alisim (available in IQ-Tree2.2-beta)
alisim.topology.unlinked.partition.model <- function(iqtree_path, output_alignment_path, partition_file_path, trees_path, 
                                                     output_format = "fasta", sequence_type = "DNA"){
  # This function uses the topology-unlinked partition model in Alisim to generate a sequence alignment
  #     containing multiple concatenated genes, each with its own tree topology and branch lengths
  
  # Assemble function call 
  function_call <- paste0(iqtree_path, " --alisim ", output_alignment_path, " -Q ", partition_file_path, " -t ",
                          trees_path, " --seqtype ", sequence_type, " -af ", output_format)
  # Invoke the OS command and call IQ-Tree
  system(function_call)
}



## Functions to process a single row from the parameters matrix and estimate an alignment using the parameters in that row
experiment1.generate.alignment <- function(row_id, output_directory, iqtree2_path, experiment_params){
  # Function to generate a single alignment given a row from the experiment 1 params dataframe
  # The alignment will be simulated from a number of random trees
  # Extract row given the row number
  row <- experiment_params[row_id, ]
  # Generate the random trees 
  generate.random.trees(num_trees = row$num_trees, num_taxa = row$num_taxa, output_filepath = paste0(output_directory, row$tree_file))
  # Generate the partition file
  partition.random.trees(num_trees = row$num_trees, al_length = row$total_alignment_length, sequence_type = row$sequence_type,
                         models = row$alisim_gene_models, rescaled_tree_lengths = row$alisim_gene_tree_length, 
                         output_filepath = paste0(output_directory, row$partition_file))
  # Call alisim in IQ-Tree2 to simulate DNA along the trees given the partition file
  alisim.topology.unlinked.partition.model(iqtree_path = iqtree2_path, output_alignment_path = paste0(output_directory, row$output_alignment_file), 
                                           partition_file_path = paste0(output_directory, row$partition_file), trees_path = paste0(output_directory, row$tree_file),
                                           output_format = "fasta", sequence_type = row$sequence_type)
  
}

experiment2.generate.alignment <- function(row_id, output_directory, iqtree2_path, experiment_params){
  # Function to generate a single alignment given a row from the experiment 1 params dataframe
  # The alignment will be simulated from a number of trees related by a single NNI move
  # Extract row given the row number
  row <- experiment_params[row_id, ]
  # Generate the random trees 
  generate.NNI.trees(num_trees = row$num_trees, num_taxa = row$num_taxa, NNI_moves = row$NNI_moves, output_filepath = paste0(output_directory, row$tree_file))
  # Generate the partition file
  partition.random.trees(num_trees = row$num_trees, al_length = row$total_alignment_length, sequence_type = row$sequence_type,
                         models = row$alisim_gene_models, rescaled_tree_lengths = row$alisim_gene_tree_length, 
                         output_filepath = paste0(output_directory, row$partition_file))
  # Call alisim in IQ-Tree2 to simulate DNA along the trees given the partition file
  alisim.topology.unlinked.partition.model(iqtree_path = iqtree2_path, output_alignment_path = paste0(output_directory, row$output_alignment_file), 
                                           partition_file_path = paste0(output_directory, row$partition_file), trees_path = paste0(output_directory, row$tree_file),
                                           output_format = "fasta", sequence_type = row$sequence_type)
  
}



## Utility functions
divisors <- function(x){
  # Function to find all divisors of x using modulo division
  y <- 1:x
  # If remainder is 0, then y is a divisor of x. Keep all divisors
  d = y[x%%y == 0]
  return(d)
}



