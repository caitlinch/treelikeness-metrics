# caitlinch/treelikeness_metrics/code/func_simulating_alignment.R
# Caitlin Cherryh 2023

#This file contains functions to simulate DNA multiple sequence alignments with varying levels of treelikeness
# Some functions require IQ-Tree2 (2.2-beta or above), or ms



## Load required packages
library(ape)
library(phangorn)
library(TreeSim)



#### Functions to generate and manipulate trees ####
generate.random.trees <- function(num_trees, num_taxa, tree_depth, output_filepath = NA){
  # This function generates n random trees with m taxa (where n is set by num_trees and m is set by num_taxa)
  # Using the `ape` function `rtree`, trees are generated by randomly splitting the edges
  
  # Generate random trees
  trees <- rmtree(num_trees, num_taxa)
  
  # Scale the depth of each tree (so the total depth is set according to the tree_depth parameter)
  for (i in 1:num_trees){
    t <- trees[[i]]
    t$edge.length <- t$edge.length * (tree_depth / max(branching.times(t)))
    trees[[i]] <- t
  }
  
  # If output filepath is provided, save trees to file
  if (!is.na(output_filepath) == TRUE){
    write.tree(trees, file = output_filepath)
  }
}


generate.NNI.trees <- function(num_trees, num_taxa,tree_depth, NNI_moves, output_filepath = NA){
  # This function generates a random tree with m taxa, and then (n-1) related trees by performing a single NNI move on the starting tree
  # (where n is num_trees and m is num_taxa)
  # Generate a single random tree using the `ape` function `rtree` 
  starting_tree <- rtree(num_taxa)
  # Determine the total number of related trees to generate
  num_related_trees = num_trees - 1
  # Perform NNI moves
  related_trees <- rNNI(starting_tree, NNI_moves, num_related_trees)
  # Collate all trees into a single multiphylo object
  trees <-  c(starting_tree, related_trees)
  
  # Scale the depth of each tree (so the total depth is set according to the tree_depth parameter)
  for (i in 1:num_trees){
    t <- trees[[i]]
    t$edge.length <- t$edge.length * (tree_depth / max(branching.times(t)))
    trees[[i]] <- t
  }
  
  # If output filepath is provided, save trees to file
  if (!is.na(output_filepath) == TRUE){
    write.tree(trees, file = output_filepath)
  }
}


scale.gene.tree.depths <- function(gene_trees, new_tree_depth){
  # Small function to take in a list of gene trees and scale them 
  
  # Scale the depth of each tree (so the total depth is set according to the provided tree_depth parameter)
  for (i in 1:length(gene_trees)){
    gt <- gene_trees[[i]]
    gt$edge.length <- gt$edge.length * (new_tree_depth / max(branching.times(gt)))
    gene_trees[[i]] <- gt
  }
  # Return the scaled gene trees
  return(gene_trees)
}



#### Functions to generate partition files ####
partition.random.trees <- function(num_trees, al_length, sequence_type, models = NA, rescaled_tree_lengths = NA, output_filepath){
  # This function generates a charpartition file for n genes (where n is num_trees) of length al_length/n 
  
  # Generate charsets
  # Find start and end point of each gene in the total alignment length
  gene_start_points <- seq(1, al_length, (al_length/num_trees))
  gene_end_points <- seq((al_length/num_trees), al_length, (al_length/num_trees))
  # Name genes
  gene_names <- sprintf("gene_%05d",1:num_trees)
  # Paste arguments together into charset lines
  csets <- paste0("\tcharset ", gene_names, " = ", sequence_type, ", ", format(gene_start_points, scientific = FALSE, trim = TRUE), "-", 
                  format(gene_end_points, scientific = FALSE, trim = TRUE), ";")
  
  # Generate model arguments
  if (!is.na(models) == TRUE){
    # If models have been provided, generate a charpartition line for the partition file
    # "models" should be a list of models with one model corresponding to one gene, or 1 model to be applied to all genes
    if (is.na(rescaled_tree_lengths) == TRUE){
      # If no rescaled_tree_lengths are provided, create the chpartitions by directly assembling the models and gene names
      gene_models <- paste0(models, ":", gene_names)
    } else if (is.na(rescaled_tree_lengths) == FALSE){
      # If rescaled_gene_lengths are provided, add them to the gene_models vector. 
      # This allows different genes to have different evolutionary rates (by specifying gene-specific tree lengths within the charpartition command)
      gene_models <- paste0(models, ":", gene_names, "{", rescaled_tree_lengths, "}")
    }
    # Assemble all sections of the charpartition command
    cpart <- paste0("\tcharpartition genes = ", paste(gene_models, collapse = ", "), ";")
  } else{
    # If no models provided, do not create a charpartition line for the partition file
    cpart <- NULL
  }
  
  # Assemble components into partition file
  c_file <- c("#nexus", "begin sets;", csets, cpart, "end;")
  
  # Write partition file
  write(c_file, file = output_filepath)
}



#### Functions to simulate alignments in Alisim (available in IQ-Tree2.2-beta) ####
alisim.topology.unlinked.partition.model <- function(iqtree_path, output_alignment_path, partition_file_path, trees_path, 
                                                     output_format = "fasta", sequence_type = "DNA"){
  # This function uses the topology-unlinked partition model in Alisim to generate a sequence alignment
  #     containing multiple concatenated genes, each with its own tree topology and branch lengths
  
  # Assemble function call 
  function_call <- paste0(iqtree_path, " --alisim ", output_alignment_path, " -Q ", partition_file_path, " -t ",
                          trees_path, " --seqtype ", sequence_type, " -af ", output_format)
  # Invoke the OS command and call IQ-Tree
  system(function_call)
}



#### Functions to process a single row from the parameters matrix and estimate an alignment using the parameters in that row ####
random.trees.generate.alignment <- function(row_id, output_directory, iqtree2_path, experiment_params){
  ## Function to generate a single alignment given a row from the experiment 1 params dataframe
  # The alignment will be simulated from a number of random trees
  
  # Extract row given the row number
  row <- experiment_params[row_id, ]
  
  # Create a new folder to store the results in this experiment from (and a file to keep a csv of the parameter values in)
  if (is.na(row$uid) == FALSE){
    row_folder <- paste0(output_directory, row$uid, "/")
    row_csv_path <- paste0(row_folder, row$uid, "_parameters.csv")
  } else if (is.na(row$uid) == TRUE & is.na(row$num_reps) == FALSE){
    row_folder <- paste0(output_directory, sprintf("%05d", row$num_trees), "_", sprintf("%04d", row$num_taxa), "_", sprintf("%03d", row$num_reps),
                         "_", row$tree_depth, "/")
    row_csv_path <- paste0(row_folder, sprintf("%05d", row$num_trees), "_", sprintf("%04d", row$num_taxa), "_", sprintf("%03d", row$num_reps),
                           "_", row$tree_depth, "_parameters.csv")
  } else {
    row_folder <- paste0(output_directory, sprintf("%05d", row$num_trees), "_", sprintf("%04d", row$num_taxa), "_", NA,
                         "_", row$tree_depth, "/")
    row_csv_path <- paste0(row_folder, sprintf("%05d", row$num_trees), "_", sprintf("%04d", row$num_taxa), "_", NA,
                           "_", row$tree_depth, "_parameters.csv")
  }
  if (dir.exists(row_folder) == FALSE){dir.create(row_folder)}
  
  # Create path for output alignment file
  output_alignment_file <- paste0(row_folder, row$output_alignment_file, ".fa")
  
  # If the output alignment does not already exist, generate the output alignment
  if (file.exists(output_alignment_file) == FALSE){
    # Generate the random trees 
    generate.random.trees(num_trees = row$num_trees, num_taxa = row$num_taxa, tree_depth = row$tree_depth, 
                          output_filepath = paste0(row_folder, row$tree_file))
    # Generate the partition file
    partition.random.trees(num_trees = row$num_trees, al_length = row$total_alignment_length, sequence_type = row$sequence_type,
                           models = row$alisim_gene_models, rescaled_tree_lengths = row$alisim_gene_tree_length, 
                           output_filepath = paste0(row_folder, row$partition_file))
    # Call alisim in IQ-Tree2 to simulate DNA along the trees given the partition file
    alisim.topology.unlinked.partition.model(iqtree_path = iqtree2_path, output_alignment_path = paste0(row_folder, row$output_alignment_file), 
                                             partition_file_path = paste0(row_folder, row$partition_file), trees_path = paste0(row_folder, row$tree_file),
                                             output_format = "fasta", sequence_type = row$sequence_type)
  }
  
  if (file.exists(row_csv_path) == FALSE){
    # If parameter csv does not exist, finalise parameter csv for output as csv file
    row$row_id <- row_id
    row$tree_file <- paste0(row_folder, row$tree_file)
    row$partition_file <- paste0(row_folder, row$partition_file)
    row$output_alignment_file <- output_alignment_file
    output_row <- row[ , c("row_id", "num_reps", "num_taxa", "num_trees", "tree_depth", "uid", "alisim_gene_models", "alisim_gene_tree_length", "total_alignment_length",
                           "sequence_type", "tree_file", "partition_file", "output_alignment_file")]
    write.csv(output_row, file = row_csv_path, row.names = FALSE)
  } else if (file.exists(row_csv_path) == TRUE) {
    # If output parameter csv exists, read it in
    output_row <- read.csv(row_csv_path)
  }
  
  # Return the dataframe row of parameters for this replicate
  return(output_row)
}


NNI.moves.generate.alignment <- function(row_id, output_directory, iqtree2_path, experiment_params_df){
  ## Function to generate a single alignment given a row from the experiment 1 params dataframe
  # The alignment will be simulated from a number of trees related by a single NNI move
  # Extract row given the row number
  row <- experiment_params_df[row_id, ]
  # Create a new folder to store the results in this experiment from
  if (is.na(row$uid) == FALSE){
    row_folder <- paste0(output_directory, row$uid, "/")
  } else if (is.na(row$uid) == TRUE & is.na(row$num_reps) == FALSE){
    row_folder <- paste0(output_directory, sprintf("%05d", row$num_trees), "_", sprintf("%04d", row$num_taxa), "_", sprintf("%03d", row$num_reps),
                         "_", row$tree_depth, "/")
  } else {
    row_folder <- paste0(output_directory, sprintf("%05d", row$num_trees), "_", sprintf("%04d", row$num_taxa), "_", NA,
                         "_", row$tree_depth, "/")
  }
  if (dir.exists(row_folder) == FALSE){dir.create(row_folder)}
  
  # Create path for output alignment file
  output_alignment_file <- paste0(row_folder, row$output_alignment_file, ".fa")
  
  # If the output alignment does not already exist, generate the output alignment
  if (file.exists(output_alignment_file) == FALSE){
    # Generate the random trees 
    generate.NNI.trees(num_trees = row$num_trees, num_taxa = row$num_taxa, tree_depth = row$tree_depth, NNI_moves = row$NNI_moves, 
                       output_filepath = paste0(row_folder, row$tree_file))
    # Generate the partition file
    partition.random.trees(num_trees = row$num_trees, al_length = row$total_alignment_length, sequence_type = row$sequence_type,
                           models = row$alisim_gene_models, rescaled_tree_lengths = row$alisim_gene_tree_length, 
                           output_filepath = paste0(row_folder, row$partition_file))
    # Call alisim in IQ-Tree2 to simulate DNA along the trees given the partition file
    alisim.topology.unlinked.partition.model(iqtree_path = iqtree2_path, output_alignment_path = paste0(row_folder, row$output_alignment_file), 
                                             partition_file_path = paste0(row_folder, row$partition_file), trees_path = paste0(row_folder, row$tree_file),
                                             output_format = "fasta", sequence_type = row$sequence_type)
  }
  
  # Return file paths (along with the row_id to make matching results easier)
  files_vec <- c(row_id,
                 paste0(row_folder, row$tree_file), 
                 paste0(row_folder, row$partition_file), 
                 output_alignment_file)
  names(files_vec) <- c("row_id", 
                        "random_tree_file", 
                        "partition_file", 
                        "alignment_file")
  return(files_vec)
}


ms.generate.alignment <- function(row_id, output_directory, ms_path, iqtree2_path, experiment_params_df, select.sister = FALSE, scale.gene.trees = TRUE){
  ## Function to generate a single alignment given a row from the experiment 2 params dataframe
  ## Generate alignments with ILS and without introgression
  ## Uses ms to generate gene trees
  
  # Extract row given the row number
  row <- experiment_params_df[row_id, ]
  
  # Create a new folder to store results for this file and create output folders for trees/gene trees/output data
  if (is.na(row$uid) == FALSE){
    uid <- row$uid
  } else if (is.na(row$uid) == TRUE & is.na(row$num_reps) == FALSE){
    uid <- paste0(sprintf("%05d", row$num_trees), "_", sprintf("%04d", row$num_taxa), "_", sprintf("%03d", row$num_reps),
                  "_", row$tree_depth_coalescent, "_", row$tree_depth_subs_per_sites, "_", row$recombination_value, "_", 
                  row$recombination_type, "_", row$speciation_rate)
  } else {
    uid <- paste0(sprintf("%05d", row$num_trees), "_", sprintf("%04d", row$num_taxa), "_", "NA",
                  "_", row$tree_depth_coalescent, "_", row$tree_depth_subs_per_sites, "_", 
                  row$recombination_value, "_", row$recombination_type, "_", row$speciation_rate)
  }
  
  row_folder            <- paste0(output_directory, uid, "/")
  row_csv_path          <- paste0(row_folder, uid, "_parameters.csv")
  start_coal_tree_file  <- paste0(row_folder, uid, "_starting_tree.txt")
  gene_trees_file       <- paste0(row_folder, uid, "_ms_gene_trees.txt")
  
  # Create the folder to store information for this row, if it doesn't already exist
  if (dir.exists(row_folder) == FALSE){dir.create(row_folder)}
  
  # Create name for output_alignment_file
  output_alignment_file <- paste0(row_folder, row$output_alignment_file, ".fa")
  
  # If the output alignment file doesn't exist, generate it
  if (file.exists(output_alignment_file) == FALSE){
    # Call ms
    ms_output_files <- ms.generate.trees(ntaxa = row$num_taxa, ntrees = row$num_trees, speciation_rate = row$speciation_rate, 
                                         tree_depth_coalescent = row$tree_depth_coalescent, recombination_value = row$recombination_value, 
                                         recombination_type = row$recombination_type, select.sister = FALSE, output_directory = row_folder,
                                         ms_path = ms_path, replicate_number = NA, unique_id = uid)
    start_coal_tree_file <- ms_output_files[[1]]
    gene_trees_file <- ms_output_files[[3]]
    # Scale the gene trees by the row$tree_depth_subs_per_sites
    if (scale.gene.trees == TRUE){
      # Open the gene tree file
      gene_trees <- read.tree(gene_trees_file)
      # Scale the gene trees
      scaled_gene_trees <- scale.gene.tree.depths(gene_trees = gene_trees, new_tree_depth = row$tree_depth_subs_per_sites)
      # Save the scaled gene trees
      write.tree(scaled_gene_trees, file = gene_trees_file)
    }
    # Generate the partition file
    gene_partition_file <- paste0(row_folder, row$partition_file)
    partition.random.trees(num_trees = row$num_trees, al_length = row$total_alignment_length, sequence_type = row$sequence_type, 
                           models = row$alisim_gene_models, rescaled_tree_lengths = row$alisim_gene_tree_length, 
                           output_filepath = gene_partition_file)
    # Generate DNA along gene trees
    alisim.topology.unlinked.partition.model(iqtree_path = iqtree2_path, output_alignment_path = paste0(row_folder, row$output_alignment_file), partition_file_path = gene_partition_file, 
                                             trees_path = gene_trees_file, output_format = "fasta", sequence_type = row$sequence_type)
  }
  
  if (file.exists(row_csv_path) == FALSE){
    # If parameter csv does not exist, finalise parameter csv for output as csv file
    row$row_id <- row_id
    row$starting_tree_file <- start_coal_tree_file
    row$gene_tree_file <- gene_trees_file
    row$partition_file <- paste0(row_folder, row$partition_file)
    row$output_alignment_file <- output_alignment_file
    output_row <- row[ , c("row_id", "num_reps", "num_taxa", "num_trees", "tree_depth_coalescent", "tree_depth_subs_per_sites",
                           "recombination_value", "recombination_type", "speciation_rate", "uid", "alisim_gene_models", "alisim_gene_tree_length", 
                           "total_alignment_length", "sequence_type", "starting_tree_file", "gene_tree_file", "partition_file", 
                           "output_alignment_file")]
    write.csv(output_row, file = row_csv_path, row.names = FALSE)
  } else if (file.exists(row_csv_path) == TRUE) {
    # If output parameter csv exists, read it in
    output_row <- read.csv(row_csv_path)
  }
  
  # Return the dataframe row of parameters for this replicate
  return(output_row)
}



#### Functions for ms ####
ms.generate.trees <- function(ntaxa, ntrees, tree_depth_coalescent, speciation_rate, recombination_value = 0, recombination_type = NA, 
                              select.sister = FALSE, output_directory, ms_path = "ms", replicate_number = NA,
                              unique_id = NA){
  ## Randomly generate a tree with n taxa; format into an ms command and run ms; generate and save the resulting gene trees
  
  ## Generate file paths using either unique id or information about this set of parameters (number of taxa/trees and replicate number)
  if (is.na(unique_id) == FALSE){
    op_unique_id <- unique_id
  } else if (is.na(unique_id) == TRUE & is.na(replicate_number) == FALSE){
    op_unique_id <- paste0(sprintf("%05d", ntrees), "_", sprintf("%04d", ntaxa), "_", sprintf("%03d", replicate_number),
                           "_", tree_depth_coalescent, "_", recombination_value, "_", recombination_type, "_", speciation_rate)
  } else {
    op_unique_id <- paste0(sprintf("%05d", ntrees), "_", sprintf("%04d", ntaxa), "_", "NA",
                           "_", tree_depth_coalescent, "_", recombination_value, "_", 
                           recombination_type, "_", speciation_rate)
  }
  t_path <- paste0(output_directory, op_unique_id, "_starting_tree.txt")
  ms_op_path <- paste0(output_directory, op_unique_id, "_ms_output.txt")
  ms_gene_trees_path <- paste0(output_directory, op_unique_id, "_ms_gene_trees.txt")
  
  ## Create a base tree for the simulations
  # Generate a tree using the TreeSim R package
  t <- sim.bd.taxa.age(n = ntaxa, numbsim = 1, lambda = speciation_rate, mu = 0, frac = 1, age = tree_depth_coalescent, mrca = TRUE)[[1]]
  # Save the random tree
  write.tree(t, file = t_path)
  
  ##
  # Calculate times for ms -ej commands by finding coalescence times (coalescent intervals found using ape::coalescent.intervals)
  ms_coal_ints <- calculate.ms.coalescent.times(t, simulation.function = "TreeSim")
  # Determine the nodes that lead to non-terminal branches {e.g. which(node.depth(t) != 1) }
  nodes <- (ntaxa+1):(ntaxa+t$Nnode)
  # Extract information about all clades from tree
  node_df <- do.call(rbind.data.frame, lapply(nodes, extract.clade.from.node, tree = t))
  names(node_df) <- c("node", "tip_names", "tip_numbers", "ms_tip_order", "ntips", "ndepth", "clade_depth", "removed_taxa", "ms_input")
  # Sort rows by clade depth
  node_df$clade_depth <- as.numeric(node_df$clade_depth)
  node_df <- node_df[order(node_df$clade_depth, decreasing = TRUE), ]
  # Add new column for the coalescence time
  node_df$coalescence_time <- ms_coal_ints
  # Format coalescences for ms input
  node_df <- determine.coalescence.taxa(node_df)
  # Create a new column containing -ej event for each row
  node_df$ej <- paste0("-ej ", node_df$coalescence_time, " ", node_df$ms_input)
  
  ## Construct a command line to call ms from a randomly generated coalescent tree
  ## If recombination_value = 0 and recombination_type = NA, do not include any recombination
  if (recombination_value == 0){
    ## No recombination event is present. Do not add any extra splitting (-es) or joining (-ej) events
    node_df <- node_df
  } else if (recombination_value != 0 & recombination_type == "Recent"){
    ## If recombination_value != 0 and recombination_type = "Recent", add one recombination event between randomly selected pair of sister taxa
    # Pick a cherry at random and create a recombination event there by using both a simultaneous -ej and -es command at 1/2*coalescent interval
    node_df <- add.recent.introgression.event(node_df, ntaxa, recombination_value, select.sister)
  } else if (recombination_value != 0 & recombination_type == "Ancient"){
    ## If recombination_value != 0 and recombination_type = "Ancient", add one recombination event between the two oldest lineages before they coalesce
    node_df <- add.ancient.introgression.event(node_df, ntaxa, recombination_value, select.sister)
  }
  
  ## Generate gene trees in ms
  # Paste together all the -ej coalescence events for this tree
  all_ej <- paste(node_df$ej, collapse = " ")
  # Construct the ms command line using the -ej events
  coal_call <- paste0(ms_path, " ", ntaxa, " ", ntrees, " -T -I ", ntaxa," ", paste(rep(1, ntaxa), collapse = " "), " ", all_ej)
  # Call ms
  ms_op <- system(coal_call, intern = TRUE)
  # Write all output to file
  write(ms_op, file = ms_op_path)
  
  ## Format and save gene trees
  # Remove non-gene tree lines from the ms output
  ms_txt <- ms_op[3:length(ms_op)] # Remove first two lines (ms command and random seeds lines)
  ms_txt <- ms_txt[which(ms_txt != "")] # Remove empty lines
  ms_txt <- ms_txt[grep("//", ms_txt, invert = TRUE)] # Remove separation lines between gene trees ("//")
  write(ms_txt, file = ms_gene_trees_path)
  
  ## Return file paths for output 
  output_files <- c(t_path, ms_op_path, ms_gene_trees_path)
  names(output_files) <- c("starting_tree_file", "ms_output_file", "ms_gene_tree_file")
  return(output_files)
}


extract.clade.from.node.coalescent_times <- function(node, tree, coalescent_times){
  ## Small function to take a node, extract the clade from that node, and return the number and names of taxa in that node
  
  # Extract clade
  clade <- extract.clade(tree, node)
  # Extract information about clade
  tip_names <- clade$tip.label
  tip_numbers <- gsub("t", "", tip_names)
  tip_order <- tip_numbers[order(as.numeric(tip_numbers), decreasing = TRUE)]
  ntips <- length(clade$tip.label)
  # Determine depth of this node (how many species does this node contain)
  ndepth <- node.depth(tree)[node]
  # Determine which coalescent time is associated with this node
  n_tree_tips <- length(tree$tip.label)
  coal_index <- node - n_tree_tips # node numbering for non-trivial tips starts at n_tree_tips+1
  coal_time <- coalescent_times[coal_index]
  # Determine which taxa to remove
  if (ndepth == 2){
    removed_taxa = tip_order[1]
    ms_input = paste0(tip_order[1], " ", tip_order[2])
  } else {
    removed_taxa = NA
    ms_input = NA
  }
  # Assemble results into a vector
  o <- c(node = node, tip_names = paste(tip_names, collapse = ","), tip_numbers = paste(tip_numbers, collapse = ","), 
         ms_tip_order = paste(tip_order, collapse = ","), ntips = ntips, ndepth = ndepth, coalescence_time = coal_time,
         removed_taxa = removed_taxa, ms_input = ms_input)
  # Return vector
  return(o)
}


extract.clade.from.node <- function(node, tree){
  ## Small function to take a node, extract the clade from that node, and return the number and names of taxa in that node
  
  # Extract clade
  clade <- extract.clade(tree, node)
  # Extract information about clade
  tip_names <- clade$tip.label
  tip_numbers <- gsub("t", "", tip_names)
  tip_order <- tip_numbers[order(as.numeric(tip_numbers), decreasing = TRUE)]
  ntips <- length(clade$tip.label)
  # Determine depth of this node (how many species does this node contain)
  ndepth <- node.depth(tree)[node]
  # Determine get the max branching time for this node - should match the coalescent time
  node_max_branching_time <- max(branching.times(clade))
  # Determine which taxa to remove
  if (ndepth == 2){
    removed_taxa = tip_order[1]
    ms_input = paste0(tip_order[1], " ", tip_order[2])
  } else {
    removed_taxa = NA
    ms_input = NA
  }
  # Assemble results into a vector
  o <- c(node = node, tip_names = paste(tip_names, collapse = ","), tip_numbers = paste(tip_numbers, collapse = ","), 
         ms_tip_order = paste(tip_order, collapse = ","), ntips = ntips, ndepth = ndepth, clade_depth = node_max_branching_time,
         removed_taxa = removed_taxa, ms_input = ms_input)
  # Return vector
  return(o)
}


calculate.ms.coalescent.times <- function(tree, simulation.function = "TreeSim"){
  ## Small function to take a number of nodes and determine all the coalescent times needed to run ms
  
  # Determine number of nodes in the tree
  number_of_nodes <- Nnode(tree)
  # Check the interval vector
  simulation.function <- tolower(simulation.function)
  # Calculate the cumulative distance between nodes  
  if (simulation.function == "treesim" | simulation.function == "yule" | simulation.function == "birth-death"){
    # Extract coalescent intervals from the tree
    # If tree generated in TreeSim, correct interval lengths by reversing the vector
    ints <- coalescent.intervals(tree)$interval.length
  } else if (simulation.function == "rcoal" | simulation.function == "ape" | simulation.function == "coalescent"){
    # Extract coalescent intervals from the tree
    # If tree generated using the rcoal() function, leave the ints as is
    ints <- coalescent.intervals(tree)$interval.length
  }
  
  # The interval length is the length between two coalescent events: to find the time for e.g. the second event, add the first and second interval together
  # The last interval should be the same as the total depth
  times_vec <- c()
  for (i in 1:number_of_nodes){
    temp_time <- sum(ints[1:i])
    times_vec <- c(times_vec, temp_time)
  }
  # Round to 6dp (to allow for values as small as 0.000001)
  times_vec <- round(times_vec, digits = 6)
  # Reverse vector so that the longest time aligns with the deepest node
  times_vec <- rev(times_vec)
  
  # Return coalescent times
  return(times_vec)
}


determine.coalescence.taxa <- function(node_dataframe){
  ## Take the node dataframe and work out which taxa will be coalescing into which (essential for the ms command line)
  
  # Convert columns used for filtering into numeric so they can be ordered properly
  node_dataframe$node <- as.numeric(node_dataframe$node)
  node_dataframe$ntips <- as.numeric(node_dataframe$ntips)
  node_dataframe$ndepth <- as.numeric(node_dataframe$ndepth)
  node_dataframe$coalescence_time <- as.numeric(node_dataframe$coalescence_time)
  # Order dataframe by node depth value
  node_dataframe <- node_dataframe[order(node_dataframe$ndepth),]
  # Make a list of all the taxa to remove
  removed_taxa <- as.numeric(node_dataframe$removed_taxa[!is.na(node_dataframe$removed_taxa)])
  # Iterate through the dataframe row by row to check 
  rows_to_process = which(is.na(node_dataframe$ms_input))
  for (i in rows_to_process){
    # Extract row
    row <- node_dataframe[i,]
    # Identify taxa in row
    row_tips <- as.numeric(unlist(strsplit(row$ms_tip_order, ",")))
    # Remove any taxa in removed_taxa
    keep_tips <- setdiff(row_tips, removed_taxa)
    ordered_keep_tips <- keep_tips[order(keep_tips, decreasing = TRUE)]
    row_ms_input <- paste0(ordered_keep_tips[1], " ", ordered_keep_tips[2])
    row_removed_tips <- c(removed_taxa, ordered_keep_tips[1])
    # Attach results back to row
    row$ms_input <- row_ms_input
    row$removed_taxa <- paste(row_removed_tips, collapse = ",")
    # Attach row back to dataframe
    node_dataframe[i,] <- row
    # Add removed taxa to list of removed taxa and remove duplicates
    removed_taxa <- unique(c(removed_taxa, row_removed_tips))
    # Repeat process with next row: the list of removed taxa will continue to grow as the node depth increases
  }
  
  # Each column should now have a nicely formatted ms_input column consisting of two lineages, with the smallest number lineage second
  #     meaning the lineages in the first population will be moved into the second subpopulation 
  #     (in the forward direction, this is equivalent to a population splitting)
  # Now, reorder the rows from longest to shortest coalescence time (in ms, the events should be put in from longest to shortest coalescent time,
  #     with the root on the left of the command and the tips on the right of the command)
  node_dataframe <- node_dataframe[order(node_dataframe$coalescence_time, decreasing = TRUE),]
  # Return the dataframe
  return(node_dataframe)
}


add.recent.introgression.event <- function(r_df, ntaxa, recombination_value, select.sister = FALSE){
  ## Function to add introgression event between two sister taxa by adding commands for simultaneous -es and -ej events 
  
  # Get candidates for introgression event (all rows in r_df with ntips = 2)
  cherry_df <- r_df[which(r_df$ntips == 2),]
  
  # Select the two taxa involved in the event
  if (select.sister == TRUE){
    # If select.sister == TRUE: pick a cherry. One species in the cherry will be receptor, other will be donor.
    # Pick one row at random
    row_pick <- sample(1:nrow(cherry_df), 1)
    row <- cherry_df[row_pick, ]
    # Get the two taxa involved in the event
    taxa <- as.numeric(unlist(strsplit(row$ms_input, " ")))
  } else if (select.sister == FALSE){
    # If select.sister == FALSE: pick any two species that are not a cherry. 
    #   Pick one species to be the receptor, and any species that is not sister to the receptor to be the donor
    # First, pick a single taxa from a single cherry
    row_pick <- sample(1:nrow(cherry_df), 1)
    row <- cherry_df[row_pick, ]
    row_taxa <- as.numeric(unlist(strsplit(row$ms_input, " ")))
    # Identify which taxa still exist at this point in time by getting a dataframe of all the coalescence events that have not yet occurred
    existing_taxa_df <- r_df[which(r_df$coalescence_time >= row$coalescence_time),]
    taxa_1 <- sample(row_taxa, 1)
    # Now get a list of all other taxa from the existing taxa r_df (i.e. all taxa that exist at this point in time)
    existing_taxa <- sort(unique(as.numeric(unlist(strsplit(existing_taxa_df$ms_input, " ")))))
    # Remove the row_taxa from all_taxa
    not_sister_taxa <- setdiff(existing_taxa, row_taxa)
    # Randomly pick one taxa from the set of not_sister_taxa
    taxa_2 <- sample(not_sister_taxa, 1)
    taxa <- c(taxa_1, taxa_2)
  }
  # Identify which taxa is the donor and which taxa is the receptor for the introgression event
  receptor = max(taxa)
  donor = min(taxa)
  
  # Set variables for the recombination event commands
  # Set coalescence time at 1/2 * row$coalescence_time 
  #     As there are no coalescence events after this (at tips, coalescence time = 0):
  #           "length of the coalescent interval" = ("time of this coalescent event" - 0) + 0
  coal_time <- 0.5 * row$coalescence_time
  # Calculate the inheritance probability (which is 1 - the rate of introgression)
  inheritance_prob <- round(1 - recombination_value, digits = 2)
  # Name the new population (must not share a name with any other population)
  new_taxa <- ntaxa+1
  
  # Create the commands for the recombination event
  # This is the the instantaneous population split: -es time_of_introgression_event population_splitting inheritance_probability
  recombination_es <- paste0("-es ", coal_time, " ", donor, " ", inheritance_prob)
  # This is the instantaneous population join: -ej time_of_introgression_event new_population recipient_population 
  recombination_ej <-  paste0("-ej ", coal_time, " ", new_taxa, " ", receptor)
  
  # Create a new row to attach to the dataframe using the two components of the recombination event
  # This is the instantaneous population join: -ej time_of_introgression_event new_population recipient_population 
  recombination_command <- paste0(recombination_es, " ", recombination_ej)
  new_row_df <- data.frame(node = NA, tip_names = paste(paste0("t", taxa), collapse = ","), tip_numbers = paste(paste0(taxa), collapse = ","), 
                           ms_tip_order = paste(sort(taxa, decreasing = TRUE), collapse = ","), ntips = 2, ndepth = NA,
                           clade_depth = NA, coalescence_time = coal_time, removed_taxa = NA, ms_input = paste0(donor, " ", receptor), ej = recombination_command)
  # Attach the new row onto the r_df
  r_df <- rbind(r_df, new_row_df)
  # Sort rows by coalescence time (longest coalescence time to shortest coalescence time)
  r_df <- r_df[order(r_df$coalescence_time, decreasing = TRUE),]
  
  # Return dataframe with recombination event added
  return(r_df)
}


add.ancient.introgression.event <- function(r_df, ntaxa, recombination_value, select.sister = FALSE){
  ## Function to add introgression event between two sister taxa by adding commands for simultaneous -es and -ej events 
  
  ## Format node dataframe in order of coalescence time, largest to smallest
  r_df <- r_df[order(r_df$coalescence_time, decreasing = TRUE),]
  
  ## Select the two taxa involved the timing of the recombination event
  if (select.sister == TRUE){
    # If selecting two taxa that are sister to each other, candidate row for introgression 
    #    will be row with the largest coalescence time (first row)
    row_id = 1
    # Extract row
    row <- r_df[row_id, ]
    # Extract taxa numbers
    taxa <- as.numeric(unlist(strsplit(row$ms_input, " ")))
    # Set coalescence time halfway along the coalescent interval
    #     [to find length of interval, subtract start of interval (second coalescence time) from end of interval (longest coalescence time)]
    coal_time <- (0.5 * (r_df$coalescence_time[row_id] - r_df$coalescence_time[row_id+1]))  + r_df$coalescence_time[row_id+1]
  } else if (select.sister == FALSE){
    # If not selecting two taxa that are sister to each other, the introgression event must take place
    #    less basally (will occur closer towards the tips)
    # Select the second and third rows (will result in 4 taxa remaining)
    row2 <- r_df[2, ]
    row3 <- r_df[3, ]
    # Identify the taxa in rows 2 and 3 (the 4 taxa present at coal_time)
    taxa2 <- as.numeric(unlist(strsplit(row2$ms_input, " ")))
    taxa3 <- as.numeric(unlist(strsplit(row3$ms_input, " ")))
    # Check whether you have four unique taxa or not
    check_four_taxa <- c(taxa2, taxa3)
    if (length(unique(check_four_taxa)) == 4){
      # If you do, randomly select one taxa from each event for the introgression event
      # To select which taxa are involved in this event, randomly select one taxa from each row
      taxa <- c(sample(taxa2, 1), sample(taxa3, 1))
    } else if (length(unique(check_four_taxa)) == 3){
      # It is possible that a taxa may occur in both events. (e.g. taxa2 = {3,4} and taxa3 = {3,15})
      # In that case, it means that first taxa 15 and 3 coalesce into taxa 3, then taxa 3 and 4 coalesce into taxa 3.
      # If it does, remove the doubled-up taxa from taxa2 (the most basal coalescence event) and use the other taxa for taxa2.
      #             Use the doubled-up taxa for taxa3. (e.g. we would select taxa 3 and 4 for this example)
      # If you did it the other way (e.g. selecting 3 and 15), you are adding an introgression event between two taxa that have
      #    just split. There is already ILS between these taxa. Adding introgression will increase the proportion of genetic 
      #    material moving between these two taxa. However selecting 3 and 4 at coal_time (1/2 way between 3rd and 4th coalescent
      #    event) does add a new source of incoming genetic material that would not otherwise exist. 
      doubled_up_taxa <- intersect(taxa2,taxa3)
      taxa2_remaining <- setdiff(taxa2, doubled_up_taxa)
      taxa <- c(doubled_up_taxa, taxa2_remaining)
    } else if (length(unique(check_four_taxa)) == 2){
      # If somehow both coalescent events involve only the same two taxa (should not be possible),
      #    simply select those as the taxa
      taxa <- unique(check_four_taxa)
    }
    
    # Set coalescence time halfway along the coalescent interval
    #     [to find length of interval, subtract start of interval (fourth coalescence time) from end of interval (third coalescence time)]
    #     That places event halfway between the point where the number of taxa becomes 4 (from 5) and the point where
    #          the number of taxa becomes 3 (from 4)
    coal_time <- (0.5 * (r_df$coalescence_time[3] - r_df$coalescence_time[4])) + r_df$coalescence_time[4]
  }
  # Get the two taxa involved in the event
  receptor = max(taxa)
  donor = min(taxa)
  
  ## Set variables for the recombination event commands
  # Calculate the inheritance probability (which is 1 - the rate of introgression)
  inheritance_prob <- round(1 - recombination_value, digits = 2)
  # Name the new population (must not share a name with any other population)
  new_taxa <- ntaxa+1
  
  ## Create the commands for the recombination event
  # This is the the instantaneous population split: -es time_of_introgression_event population_splitting inheritance_probability
  recombination_es <- paste0("-es ", coal_time, " ", donor, " ", inheritance_prob)
  # This is the instantaneous population join: -ej time_of_introgression_event new_population recipient_population 
  recombination_ej <-  paste0("-ej ", coal_time, " ", new_taxa, " ", receptor)
  
  ## Create a new row to attach to the dataframe using the two components of the recombination event
  # This is the instantaneous population join: -ej time_of_introgression_event new_population recipient_population 
  recombination_command <- paste0(recombination_es, " ", recombination_ej)
  if (select.sister == TRUE){
    new_row_df <- data.frame(node = NA, tip_names = row$tip_names, tip_numbers = row$tip_numbers, ms_tip_order = row$ms_tip_order, ntips = NA, ndepth = NA,
                             clade_depth = NA, coalescence_time = coal_time, removed_taxa = NA, ms_input = paste0(donor, " ", receptor), ej = recombination_command)
  } else if (select.sister == FALSE){
    new_row_df <- data.frame(node = NA, tip_names = NA, tip_numbers = NA, ms_tip_order = NA, ntips = NA, ndepth = NA,
                             clade_depth = NA, coalescence_time = coal_time, removed_taxa = NA, ms_input = paste0(donor, " ", receptor), ej = recombination_command)
  }
  ## Attach the new row onto the r_df
  r_df <- rbind(r_df, new_row_df)
  # Sort rows by coalescence time (longest coalescence time to shortest coalescence time)
  r_df <- r_df[order(r_df$coalescence_time, decreasing = TRUE),]
  
  ## Return dataframe with recombination event added
  return(r_df)
}



#### Utility functions ####
divisors <- function(x){
  # Function to find all divisors of x using modulo division
  y <- 1:x
  # If remainder is 0, then y is a divisor of x. Keep all divisors
  d = y[x%%y == 0]
  return(d)
}


