#### caitlinch/treelikeness_metrics/func_simulating_alignment.R
## This file contains functions to simulate DNA multiple sequence alignments with varying levels of treelikeness

## Load required packages
library(ape)
library(phangorn)



#### Functions to generate and manipulate trees ####
generate.random.trees <- function(num_trees, num_taxa, output_filepath = NA){
  # This function generates n random trees with m taxa (where n is set by num_trees and m is set by num_taxa)
  # Using the `ape` function `rtree`, trees are generated by randomly splitting the edges
  
  # Generate random trees
  trees <- rmtree(num_trees, num_taxa)
  
  # If output filepath is provided, save trees to file
  if (!is.na(output_filepath) == TRUE){
    write.tree(trees, file = output_filepath)
  }
}

generate.NNI.trees <- function(num_trees, num_taxa, NNI_moves, output_filepath = NA){
  # This function generates a random tree with m taxa, and then (n-1) related trees by performing a single NNI move on the starting tree
  # (where n is num_trees and m is num_taxa)
  # Generate a single random tree using the `ape` function `rtree` 
  starting_tree <- rtree(num_taxa)
  # Determine the total number of related trees to generate
  num_related_trees = num_trees - 1
  # Perform NNI moves
  related_trees <- rNNI(starting_tree, NNI_moves, num_related_trees)
  # Collate all trees into a single multiphylo object
  trees <-  c(starting_tree, related_trees)
  
  # If output filepath is provided, save trees to file
  if (!is.na(output_filepath) == TRUE){
    write.tree(trees, file = output_filepath)
  }
}


#### Functions to generate partition files ####
partition.random.trees <- function(num_trees, al_length, sequence_type, models = NA, rescaled_tree_lengths = NA, output_filepath){
  # This function generates a charpartition file for n genes (where n is num_trees) of length al_length/n 
  
  # Generate charsets
  # Find start and end point of each gene in the total alignment length
  gene_start_points <- seq(1, al_length, (al_length/num_trees))
  gene_end_points <- seq((al_length/num_trees), al_length, (al_length/num_trees))
  # Name genes
  gene_names <- sprintf("gene_%05d",1:num_trees)
  # Paste arguments together into charset lines
  csets <- paste0("\tcharset ", gene_names, " = ", sequence_type, ", ", gene_start_points, "-", gene_end_points, ";")
  
  # Generate model arguments
  if (!is.na(models) == TRUE){
    # If models have been provided, generate a charpartition line for the partition file
    # "models" should be a list of models with one model corresponding to one gene, or 1 model to be applied to all genes
    if (is.na(rescaled_tree_lengths) == TRUE){
      # If no rescaled_tree_lengths are provided, create the chpartitions by directly assembling the models and gene names
      gene_models <- paste0(models, ":", gene_names)
    } else if (is.na(rescaled_tree_lengths) == FALSE){
      # If rescaled_gene_lengths are provided, add them to the gene_models vector. 
      # This allows different genes to have different evolutionary rates (by specifying gene-specific tree lengths within the charpartition command)
      gene_models <- paste0(models, ":", gene_names, "{", rescaled_tree_lengths, "}")
    }
    # Assemble all sections of the charpartition command
    cpart <- paste0("\tcharpartition genes = ", paste(gene_models, collapse = ", "), ";")
  } else{
    # If no models provided, do not create a charpartition line for the partition file
    cpart <- NULL
  }
  
  # Assemble components into partition file
  c_file <- c("#nexus", "begin sets;", csets, cpart, "end;")
  
  # Write partition file
  write(c_file, file = output_filepath)
}



#### Functions to simulate alignments in Alisim (available in IQ-Tree2.2-beta) ####
alisim.topology.unlinked.partition.model <- function(iqtree_path, output_alignment_path, partition_file_path, trees_path, 
                                                     output_format = "fasta", sequence_type = "DNA"){
  # This function uses the topology-unlinked partition model in Alisim to generate a sequence alignment
  #     containing multiple concatenated genes, each with its own tree topology and branch lengths
  
  # Assemble function call 
  function_call <- paste0(iqtree_path, " --alisim ", output_alignment_path, " -Q ", partition_file_path, " -t ",
                          trees_path, " --seqtype ", sequence_type, " -af ", output_format)
  # Invoke the OS command and call IQ-Tree
  system(function_call)
}



#### Functions to process a single row from the parameters matrix and estimate an alignment using the parameters in that row ####
random.trees.generate.alignment <- function(row_id, output_directory, iqtree2_path, experiment_params){
  # Function to generate a single alignment given a row from the experiment 1 params dataframe
  # The alignment will be simulated from a number of random trees
  # Extract row given the row number
  row <- experiment_params[row_id, ]
  # Generate the random trees 
  generate.random.trees(num_trees = row$num_trees, num_taxa = row$num_taxa, output_filepath = paste0(output_directory, row$tree_file))
  # Generate the partition file
  partition.random.trees(num_trees = row$num_trees, al_length = row$total_alignment_length, sequence_type = row$sequence_type,
                         models = row$alisim_gene_models, rescaled_tree_lengths = row$alisim_gene_tree_length, 
                         output_filepath = paste0(output_directory, row$partition_file))
  # Call alisim in IQ-Tree2 to simulate DNA along the trees given the partition file
  alisim.topology.unlinked.partition.model(iqtree_path = iqtree2_path, output_alignment_path = paste0(output_directory, row$output_alignment_file), 
                                           partition_file_path = paste0(output_directory, row$partition_file), trees_path = paste0(output_directory, row$tree_file),
                                           output_format = "fasta", sequence_type = row$sequence_type)
  
}

NNI.moves.generate.alignment <- function(row_id, output_directory, iqtree2_path, experiment_params){
  # Function to generate a single alignment given a row from the experiment 1 params dataframe
  # The alignment will be simulated from a number of trees related by a single NNI move
  # Extract row given the row number
  row <- experiment_params[row_id, ]
  # Generate the random trees 
  generate.NNI.trees(num_trees = row$num_trees, num_taxa = row$num_taxa, NNI_moves = row$NNI_moves, output_filepath = paste0(output_directory, row$tree_file))
  # Generate the partition file
  partition.random.trees(num_trees = row$num_trees, al_length = row$total_alignment_length, sequence_type = row$sequence_type,
                         models = row$alisim_gene_models, rescaled_tree_lengths = row$alisim_gene_tree_length, 
                         output_filepath = paste0(output_directory, row$partition_file))
  # Call alisim in IQ-Tree2 to simulate DNA along the trees given the partition file
  alisim.topology.unlinked.partition.model(iqtree_path = iqtree2_path, output_alignment_path = paste0(output_directory, row$output_alignment_file), 
                                           partition_file_path = paste0(output_directory, row$partition_file), trees_path = paste0(output_directory, row$tree_file),
                                           output_format = "fasta", sequence_type = row$sequence_type)
  
}



#### Functions for ms ####
extract.clade.from.node <- function(node, tree, coalescent_times){
  ## Small function to take a node, extract the clade from that node, and return the number and names of taxa in that node
  
  # Extract clade
  clade <- extract.clade(tree, node)
  # Extract information about clade
  tip_names <- clade$tip.label
  tip_numbers <- gsub("t", "", tip_names)
  tip_order <- tip_numbers[order(as.numeric(tip_numbers), decreasing = TRUE)]
  ntips <- length(clade$tip.label)
  # Determine depth of this node (how many species does this node contain)
  ndepth <- node.depth(tree)[node]
  # Determine which coalescent time is associated with this node
  n_tree_tips <- length(tree$tip.label)
  coal_index <- node - n_tree_tips # node numbering for non-trivial tips starts at n_tree_tips+1
  coal_time <- coalescent_times[coal_index]
  # Assemble a command for ms coalescing the taxa involved in this node into an ms command
  
  # Assemble results into a vector
  l <- list(node = node, tip_names = tip_names, tip_numbers = tip_numbers, ms_tip_order = tip_order, ntips = ntips, ndepth = ndepth, coalescence_time = coal_time)
  # Return vector
  return(l)
}

calculate.ms.coalescent.times <- function(number_of_nodes, coalescent_intervals){
  ## Small function to take a number of nodes and determine all the coalescent times needed to run ms
  
  ints <- coalescent_intervals$interval.length
  # The interval length is the length between two coalescent events: to find the time for e.g. the second event, add the first and second interval together
  # The last interval should be the same as the total depth
  times_vec <- c()
  for (i in 1:4){
    temp_time <- sum(ints[1:i])
    times_vec <- c(times_vec, temp_time)
  }
  
  # Round to 3dp (to allow for values as small as 0.001)
  times_vec <- round(times_vec, digits = 3)
  # Return coalescent times
  return(times_vec)
}


#### Utility functions ####
divisors <- function(x){
  # Function to find all divisors of x using modulo division
  y <- 1:x
  # If remainder is 0, then y is a divisor of x. Keep all divisors
  d = y[x%%y == 0]
  return(d)
}



